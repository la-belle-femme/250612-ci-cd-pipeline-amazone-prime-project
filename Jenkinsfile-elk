pipeline {
    agent any
    
    environment {
        // EKS Configuration
        EKS_CLUSTER_NAME = "${params.EKS_CLUSTER_NAME ?: 'amazon-prime-eks'}"
        AWS_REGION = "${params.AWS_REGION ?: 'us-east-1'}"
        NAMESPACE = "${params.NAMESPACE ?: 'elastic-stack'}"
        
        // Elasticsearch Configuration
        ES_VERSION = "${params.ES_VERSION ?: '8.11.0'}"
        ES_REPLICAS = "${params.ES_REPLICAS ?: '3'}"
        ES_STORAGE_SIZE = "${params.ES_STORAGE_SIZE ?: '100Gi'}"
        ES_MEMORY_LIMIT = "${params.ES_MEMORY_LIMIT ?: '4Gi'}"
        
        // Kibana Configuration
        KIBANA_VERSION = "${params.KIBANA_VERSION ?: '8.11.0'}"
        KIBANA_REPLICAS = "${params.KIBANA_REPLICAS ?: '2'}"
        KIBANA_MEMORY_LIMIT = "${params.KIBANA_MEMORY_LIMIT ?: '4Gi'}"
        KIBANA_DOMAIN = "${params.KIBANA_DOMAIN ?: 'kibana.yourdomain.com'}"
        
        // Deployment Configuration
        DEPLOYMENT_MODE = "${params.DEPLOYMENT_MODE ?: 'full-stack'}"
        ENABLE_SSL = "${params.ENABLE_SSL ?: 'false'}"
        
        // Security
        ES_PASSWORD = credentials('elasticsearch-password')
        KIBANA_ENCRYPTION_KEY = credentials('kibana-encryption-key')
    }
    
    parameters {
        choice(
            name: 'DEPLOYMENT_MODE',
            choices: ['full-stack', 'elasticsearch-only', 'kibana-only'],
            description: 'What to deploy'
        )
        choice(
            name: 'ACTION',
            choices: ['deploy', 'upgrade', 'rollback', 'uninstall'],
            description: 'Deployment action'
        )
        string(
            name: 'EKS_CLUSTER_NAME',
            defaultValue: 'amazon-prime-eks',
            description: 'EKS cluster name'
        )
        string(
            name: 'KIBANA_DOMAIN',
            defaultValue: 'kibana-test.local',
            description: 'Kibana domain name'
        )
        booleanParam(
            name: 'ENABLE_SSL',
            defaultValue: false,
            description: 'Enable SSL/TLS with ACM certificate'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: true,
            description: 'Perform dry run without actual deployment'
        )
    }
    
    stages {
        stage('Preparation') {
            steps {
                script {
                    echo "üöÄ Starting ELK Stack Deployment Pipeline"
                    echo "Cluster: ${EKS_CLUSTER_NAME}"
                    echo "Namespace: ${NAMESPACE}"
                    echo "Mode: ${DEPLOYMENT_MODE}"
                    echo "Action: ${params.ACTION}"
                    echo "Dry Run: ${params.DRY_RUN}"
                }
            }
        }
        
        stage('Prerequisites Check') {
            steps {
                script {
                    echo "üîç Checking AWS connectivity..."
                    sh "aws sts get-caller-identity"
                    sh "aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}"
                    
                    echo "üîç Checking Kubernetes connectivity..."
                    sh "aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}"
                    sh "kubectl cluster-info"
                    sh "kubectl get nodes"
                    sh "kubectl get storageclass"
                    
                    echo "üîç Setting up Helm repositories..."
                    sh "helm repo add elastic https://helm.elastic.co"
                    sh "helm repo update"
                    sh "helm version"
                }
            }
        }
        
        stage('Namespace & Secrets') {
            when {
                anyOf {
                    expression { params.ACTION == 'deploy' }
                    expression { params.ACTION == 'upgrade' }
                }
            }
            steps {
                script {
                    echo "üèóÔ∏è Creating namespace and secrets..."
                    sh "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
                    
                    // Create Elasticsearch password secret
                    sh """
                        kubectl create secret generic elasticsearch-master-credentials \\
                            --from-literal=password='${ES_PASSWORD}' \\
                            -n ${NAMESPACE} \\
                            --dry-run=client -o yaml | kubectl apply -f -
                    """
                    
                    // Create Kibana encryption key secret
                    sh """
                        kubectl create secret generic kibana-encryption-key \\
                            --from-literal=encryptionkey='${KIBANA_ENCRYPTION_KEY}' \\
                            -n ${NAMESPACE} \\
                            --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
            }
        }
        
        stage('Deploy Elasticsearch') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'elasticsearch-only' }
                    }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    writeFile file: 'elasticsearch-values.yaml', text: """
# Elasticsearch Values for EKS Production
clusterName: "elasticsearch"
nodeGroup: "master"

roles:
  master: "true"
  ingest: "true"
  data: "true"
  remote_cluster_client: "true"

replicas: ${ES_REPLICAS}

image: "docker.elastic.co/elasticsearch/elasticsearch"
imageTag: "${ES_VERSION}"

resources:
  requests:
    cpu: "1000m"
    memory: "2Gi"
  limits:
    cpu: "2000m"
    memory: "${ES_MEMORY_LIMIT}"

esJavaOpts: "-Xmx2g -Xms2g"

volumeClaimTemplate:
  accessModes: [ "ReadWriteOnce" ]
  storageClassName: gp3
  resources:
    requests:
      storage: "${ES_STORAGE_SIZE}"

service:
  type: ClusterIP

secret:
  enabled: true
  password: "changeme"

esConfig:
  elasticsearch.yml: |
    cluster.name: "elasticsearch"
    network.host: 0.0.0.0
    discovery.seed_hosts: "elasticsearch-master-headless"
    cluster.initial_master_nodes: "elasticsearch-master-0,elasticsearch-master-1,elasticsearch-master-2"
    indices.memory.index_buffer_size: 20%
    xpack.security.enabled: true
    xpack.security.transport.ssl.enabled: true
    xpack.security.transport.ssl.verification_mode: certificate
    xpack.security.transport.ssl.client_authentication: required
    xpack.security.transport.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
    xpack.security.transport.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
    xpack.security.http.ssl.enabled: false

antiAffinity: "hard"
maxUnavailable: 1

extraEnvs:
  - name: ELASTIC_PASSWORD
    valueFrom:
      secretKeyRef:
        name: elasticsearch-master-credentials
        key: password
"""
                    
                    if (params.DRY_RUN) {
                        echo "üß™ DRY RUN: Elasticsearch deployment"
                        sh """
                            helm template elasticsearch elastic/elasticsearch \\
                                -f elasticsearch-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${ES_VERSION}
                        """
                    } else {
                        echo "üöÄ Deploying Elasticsearch..."
                        sh """
                            helm upgrade --install elasticsearch elastic/elasticsearch \\
                                -f elasticsearch-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${ES_VERSION} \\
                                --timeout 15m \\
                                --wait
                        """
                    }
                }
            }
        }
        
        stage('Verify Elasticsearch') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'elasticsearch-only' }
                    }
                    expression { !params.DRY_RUN }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    echo "üîç Verifying Elasticsearch deployment..."
                    sh "kubectl wait --for=condition=ready pod -l app=elasticsearch-master -n ${NAMESPACE} --timeout=600s"
                    sh "kubectl get pods -n ${NAMESPACE} -l app=elasticsearch-master"
                    
                    // Test Elasticsearch health
                    sh """
                        kubectl exec -n ${NAMESPACE} elasticsearch-master-0 -- \\
                            curl -u "elastic:${ES_PASSWORD}" \\
                            -H "Content-Type: application/json" \\
                            http://localhost:9200/_cluster/health?pretty
                    """
                }
            }
        }
        
        stage('Deploy Kibana') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'kibana-only' }
                    }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    writeFile file: 'kibana-values.yaml', text: """
# Kibana Values for EKS Production
elasticsearchHosts: "http://elasticsearch-master:9200"

replicas: ${KIBANA_REPLICAS}

image: "docker.elastic.co/kibana/kibana"
imageTag: "${KIBANA_VERSION}"

resources:
  requests:
    cpu: "1000m"
    memory: "2Gi"
  limits:
    cpu: "2000m"
    memory: "${KIBANA_MEMORY_LIMIT}"

service:
  type: ClusterIP
  port: 5601

ingress:
  enabled: true
  className: "alb"
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/healthcheck-path: /api/status
  hosts:
    - host: "${KIBANA_DOMAIN}"
      paths:
        - path: /
          pathType: Prefix

extraEnvs:
  - name: "ELASTICSEARCH_USERNAME"
    value: "elastic"
  - name: "ELASTICSEARCH_PASSWORD"
    valueFrom:
      secretKeyRef:
        name: elasticsearch-master-credentials
        key: password
  - name: "XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY"
    valueFrom:
      secretKeyRef:
        name: kibana-encryption-key
        key: encryptionkey

kibanaConfig:
  kibana.yml: |
    server.name: "kibana"
    server.host: "0.0.0.0"
    server.publicBaseUrl: "http://${KIBANA_DOMAIN}"
    elasticsearch.hosts: ["http://elasticsearch-master:9200"]
    elasticsearch.username: "\${ELASTICSEARCH_USERNAME}"
    elasticsearch.password: "\${ELASTICSEARCH_PASSWORD}"
    xpack.security.encryptionKey: "\${XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY}"
    elasticsearch.requestTimeout: 90000
    ops.interval: 30000
    logging.root.level: warn

persistence:
  enabled: true
  size: 10Gi
  storageClass: "gp3"

antiAffinity: "soft"
"""
                    
                    if (params.DRY_RUN) {
                        echo "üß™ DRY RUN: Kibana deployment"
                        sh """
                            helm template kibana elastic/kibana \\
                                -f kibana-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${KIBANA_VERSION}
                        """
                    } else {
                        echo "üöÄ Deploying Kibana..."
                        sh """
                            helm upgrade --install kibana elastic/kibana \\
                                -f kibana-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${KIBANA_VERSION} \\
                                --timeout 10m \\
                                --wait
                        """
                    }
                }
            }
        }
        
        stage('Verify Kibana') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'kibana-only' }
                    }
                    expression { !params.DRY_RUN }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    echo "üîç Verifying Kibana deployment..."
                    sh "kubectl wait --for=condition=ready pod -l app=kibana -n ${NAMESPACE} --timeout=300s"
                    sh "kubectl get pods -n ${NAMESPACE} -l app=kibana"
                    sh "kubectl get ingress -n ${NAMESPACE}"
                    
                    echo """
üìã Deployment Summary:
Namespace: ${NAMESPACE}
Kibana URL: http://${KIBANA_DOMAIN}
Username: elastic
Password: ${ES_PASSWORD}
                    """
                }
            }
        }
    }
    
    post {
        always {
            script {
                if (!params.DRY_RUN && params.ACTION != 'uninstall') {
                    sh """
                        echo "üìä Final Status Check:"
                        kubectl get all -n ${NAMESPACE} || true
                    """
                }
            }
        }
        success {
            echo "‚úÖ ELK Stack deployment completed successfully!"
            script {
                if (!params.DRY_RUN && (params.ACTION == 'deploy' || params.ACTION == 'upgrade')) {
                    echo """
üéâ Deployment Successful!

Access Information:
- Kibana URL: http://${KIBANA_DOMAIN}
- Username: elastic  
- Password: Check Jenkins credentials 'elasticsearch-password'
- Namespace: ${NAMESPACE}

Next Steps:
1. Configure user authentication
2. Set up index patterns
3. Create dashboards for your 50 users
4. Configure data retention policies
                    """
                }
            }
        }
        failure {
            echo "‚ùå ELK Stack deployment failed!"
            sh """
                echo "üîç Debugging information:"
                kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' || true
                kubectl get pods -n ${NAMESPACE} -o wide || true
            """ 
        }
    }
}
