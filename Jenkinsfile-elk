pipeline {
    agent any
    
    environment {
        // EKS Configuration
        EKS_CLUSTER_NAME = "${params.EKS_CLUSTER_NAME ?: 'amazon-prime-eks'}"
        AWS_REGION = "${params.AWS_REGION ?: 'us-east-1'}"
        NAMESPACE = "${params.NAMESPACE ?: 'elastic-stack'}"
        
        // Elasticsearch Configuration - Updated to available version
        ES_VERSION = "${params.ES_VERSION ?: '8.5.1'}"
        ES_REPLICAS = "${params.ES_REPLICAS ?: '3'}"
        ES_STORAGE_SIZE = "${params.ES_STORAGE_SIZE ?: '100Gi'}"
        ES_MEMORY_LIMIT = "${params.ES_MEMORY_LIMIT ?: '4Gi'}"
        
        // Kibana Configuration - Updated to available version
        KIBANA_VERSION = "${params.KIBANA_VERSION ?: '8.5.1'}"
        KIBANA_REPLICAS = "${params.KIBANA_REPLICAS ?: '2'}"
        KIBANA_MEMORY_LIMIT = "${params.KIBANA_MEMORY_LIMIT ?: '4Gi'}"
        KIBANA_DOMAIN = "${params.KIBANA_DOMAIN ?: 'kibana.yourdomain.com'}"
        
        // Deployment Configuration
        DEPLOYMENT_MODE = "${params.DEPLOYMENT_MODE ?: 'full-stack'}"
        ENABLE_SSL = "${params.ENABLE_SSL ?: 'false'}"
        
        // Security
        ES_PASSWORD = credentials('elasticsearch-password')
        KIBANA_ENCRYPTION_KEY = credentials('kibana-encryption-key')
    }
    
    parameters {
        choice(
            name: 'DEPLOYMENT_MODE',
            choices: ['full-stack', 'elasticsearch-only', 'kibana-only'],
            description: 'What to deploy'
        )
        choice(
            name: 'ACTION',
            choices: ['deploy', 'upgrade', 'rollback', 'uninstall'],
            description: 'Deployment action'
        )
        string(
            name: 'EKS_CLUSTER_NAME',
            defaultValue: 'amazon-prime-eks',
            description: 'EKS cluster name'
        )
        string(
            name: 'KIBANA_DOMAIN',
            defaultValue: 'kibana-test.local',
            description: 'Kibana domain name'
        )
        booleanParam(
            name: 'ENABLE_SSL',
            defaultValue: false,
            description: 'Enable SSL/TLS with ACM certificate'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: true,
            description: 'Perform dry run without actual deployment'
        )
    }
    
    stages {
        stage('Preparation') {
            steps {
                script {
                    echo "üöÄ Starting ELK Stack Deployment Pipeline"
                    echo "Cluster: ${EKS_CLUSTER_NAME}"
                    echo "Namespace: ${NAMESPACE}"
                    echo "Mode: ${DEPLOYMENT_MODE}"
                    echo "Action: ${params.ACTION}"
                    echo "Dry Run: ${params.DRY_RUN}"
                    echo "ES Version: ${ES_VERSION}"
                    echo "Kibana Version: ${KIBANA_VERSION}"
                }
            }
        }
        
        stage('Prerequisites Check') {
            steps {
                script {
                    echo "üîç Checking AWS connectivity..."
                    sh "aws sts get-caller-identity"
                    sh "aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}"
                    
                    echo "üîç Checking Kubernetes connectivity..."
                    sh "aws eks update-kubeconfig --name ${EKS_CLUSTER_NAME} --region ${AWS_REGION}"
                    sh "kubectl cluster-info"
                    sh "kubectl get nodes"
                    sh "kubectl get storageclass"
                    
                    echo "üîç Setting up Helm repositories..."
                    sh "helm repo add elastic https://helm.elastic.co"
                    sh "helm repo update"
                    sh "helm version"
                    
                    echo "üîç Checking available chart versions..."
                    sh "helm search repo elastic/elasticsearch --versions | head -3"
                    sh "helm search repo elastic/kibana --versions | head -3"
                }
            }
        }
        
        stage('Namespace & Cleanup') {
            when {
                anyOf {
                    expression { params.ACTION == 'deploy' }
                    expression { params.ACTION == 'upgrade' }
                }
            }
            steps {
                script {
                    echo "üèóÔ∏è Creating namespace and cleaning up existing secrets..."
                    sh "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
                    
                    // Clean up any existing secrets that might conflict with Helm
                    echo "üßπ Cleaning existing secrets to avoid Helm ownership conflicts..."
                    sh """
                        kubectl delete secret elasticsearch-master-credentials -n ${NAMESPACE} --ignore-not-found=true
                        kubectl delete secret kibana-encryption-key -n ${NAMESPACE} --ignore-not-found=true
                    """
                    echo "‚ÑπÔ∏è Secrets will be managed by Helm charts with proper ownership"
                }
            }
        }
        
        stage('Deploy Elasticsearch') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'elasticsearch-only' }
                    }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    writeFile file: 'elasticsearch-values.yaml', text: """
# Elasticsearch Values for EKS Production - Helm Managed Secrets
clusterName: "elasticsearch"
nodeGroup: "master"

# Fixed roles format for Elasticsearch 8.5.1
roles:
  - master
  - ingest
  - data
  - remote_cluster_client

replicas: ${ES_REPLICAS}

image: "docker.elastic.co/elasticsearch/elasticsearch"
imageTag: "${ES_VERSION}"

resources:
  requests:
    cpu: "1000m"
    memory: "2Gi"
  limits:
    cpu: "2000m"
    memory: "${ES_MEMORY_LIMIT}"

esJavaOpts: "-Xmx2g -Xms2g"

volumeClaimTemplate:
  accessModes: [ "ReadWriteOnce" ]
  storageClassName: gp2
  resources:
    requests:
      storage: "${ES_STORAGE_SIZE}"

service:
  type: ClusterIP

# Let Helm manage the secret with custom password
secret:
  enabled: true
  password: "${ES_PASSWORD}"

esConfig:
  elasticsearch.yml: |
    cluster.name: "elasticsearch"
    network.host: 0.0.0.0
    discovery.seed_hosts: "elasticsearch-master-headless"
    cluster.initial_master_nodes: "elasticsearch-master-0,elasticsearch-master-1,elasticsearch-master-2"
    indices.memory.index_buffer_size: 20%
    xpack.security.enabled: true
    xpack.security.transport.ssl.enabled: true
    xpack.security.transport.ssl.verification_mode: certificate
    xpack.security.transport.ssl.client_authentication: required
    xpack.security.transport.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
    xpack.security.transport.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
    xpack.security.http.ssl.enabled: false

antiAffinity: "hard"
maxUnavailable: 1

# Use Helm-managed secret
extraEnvs:
  - name: ELASTIC_PASSWORD
    valueFrom:
      secretKeyRef:
        name: elasticsearch-master-credentials
        key: password
"""
                    
                    if (params.DRY_RUN) {
                        echo "üß™ DRY RUN: Elasticsearch deployment"
                        sh """
                            helm template elasticsearch elastic/elasticsearch \\
                                -f elasticsearch-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${ES_VERSION}
                        """
                    } else {
                        echo "üöÄ Deploying Elasticsearch..."
                        sh """
                            helm upgrade --install elasticsearch elastic/elasticsearch \\
                                -f elasticsearch-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${ES_VERSION} \\
                                --timeout 15m \\
                                --wait
                        """
                    }
                }
            }
        }
        
        stage('Verify Elasticsearch') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'elasticsearch-only' }
                    }
                    expression { !params.DRY_RUN }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    echo "üîç Verifying Elasticsearch deployment..."
                    sh "kubectl wait --for=condition=ready pod -l app=elasticsearch-master -n ${NAMESPACE} --timeout=600s"
                    sh "kubectl get pods -n ${NAMESPACE} -l app=elasticsearch-master"
                    
                    // Test Elasticsearch health
                    sh """
                        kubectl exec -n ${NAMESPACE} elasticsearch-master-0 -- \\
                            curl -u "elastic:${ES_PASSWORD}" \\
                            -H "Content-Type: application/json" \\
                            http://localhost:9200/_cluster/health?pretty
                    """
                }
            }
        }
        
        stage('Deploy Kibana') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'kibana-only' }
                    }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    writeFile file: 'kibana-values.yaml', text: """
# Kibana Values for EKS Production - Helm Managed Secrets
elasticsearchHosts: "http://elasticsearch-master:9200"

replicas: ${KIBANA_REPLICAS}

image: "docker.elastic.co/kibana/kibana"
imageTag: "${KIBANA_VERSION}"

resources:
  requests:
    cpu: "1000m"
    memory: "2Gi"
  limits:
    cpu: "2000m"
    memory: "${KIBANA_MEMORY_LIMIT}"

service:
  type: ClusterIP
  port: 5601

ingress:
  enabled: true
  className: "alb"
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/healthcheck-path: /api/status
  hosts:
    - host: "${KIBANA_DOMAIN}"
      paths:
        - path: /
          pathType: Prefix

# Use direct values instead of separate secrets to avoid Helm ownership conflicts
extraEnvs:
  - name: "ELASTICSEARCH_USERNAME"
    value: "elastic"
  - name: "ELASTICSEARCH_PASSWORD"
    valueFrom:
      secretKeyRef:
        name: elasticsearch-master-credentials
        key: password
  - name: "XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY"
    value: "${KIBANA_ENCRYPTION_KEY}"
  - name: "NODE_OPTIONS"
    value: "--max-old-space-size=3584"

kibanaConfig:
  kibana.yml: |
    server.name: "kibana"
    server.host: "0.0.0.0"
    server.publicBaseUrl: "http://${KIBANA_DOMAIN}"
    elasticsearch.hosts: ["http://elasticsearch-master:9200"]
    elasticsearch.username: "\${ELASTICSEARCH_USERNAME}"
    elasticsearch.password: "\${ELASTICSEARCH_PASSWORD}"
    xpack.security.encryptionKey: "\${XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY}"
    elasticsearch.requestTimeout: 90000
    ops.interval: 30000
    logging.root.level: warn
    data.search.aggs.shardDelay.enabled: true
    xpack.monitoring.kibana.collection.enabled: true

persistence:
  enabled: true
  size: 10Gi
  storageClass: "gp2"

antiAffinity: "soft"
"""
                    
                    if (params.DRY_RUN) {
                        echo "üß™ DRY RUN: Kibana deployment"
                        sh """
                            helm template kibana elastic/kibana \\
                                -f kibana-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${KIBANA_VERSION}
                        """
                    } else {
                        echo "üöÄ Deploying Kibana..."
                        sh """
                            helm upgrade --install kibana elastic/kibana \\
                                -f kibana-values.yaml \\
                                -n ${NAMESPACE} \\
                                --version ${KIBANA_VERSION} \\
                                --timeout 10m \\
                                --wait
                        """
                    }
                }
            }
        }
        
        stage('Verify Kibana') {
            when {
                allOf {
                    anyOf {
                        expression { DEPLOYMENT_MODE == 'full-stack' }
                        expression { DEPLOYMENT_MODE == 'kibana-only' }
                    }
                    expression { !params.DRY_RUN }
                    anyOf {
                        expression { params.ACTION == 'deploy' }
                        expression { params.ACTION == 'upgrade' }
                    }
                }
            }
            steps {
                script {
                    echo "üîç Verifying Kibana deployment..."
                    sh "kubectl wait --for=condition=ready pod -l app=kibana -n ${NAMESPACE} --timeout=300s"
                    sh "kubectl get pods -n ${NAMESPACE} -l app=kibana"
                    sh "kubectl get ingress -n ${NAMESPACE}"
                    
                    // Get load balancer URL
                    sh """
                        echo "üìã Getting LoadBalancer URL..."
                        kubectl get ingress -n ${NAMESPACE} kibana-kibana -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "LoadBalancer URL not ready yet"
                    """
                    
                    echo """
üìã Deployment Summary:
Namespace: ${NAMESPACE}
Kibana Domain: ${KIBANA_DOMAIN}
Username: elastic
Password: Check Jenkins credentials 'elasticsearch-password'

üéâ ELK Stack deployed successfully!
‚úÖ Elasticsearch: 3 pods running
‚úÖ Kibana: ${KIBANA_REPLICAS} pods running
‚úÖ Storage: ${ES_STORAGE_SIZE} per ES pod
‚úÖ Ready for 50 users!
                    """
                }
            }
        }
        
        stage('Rollback') {
            when {
                expression { params.ACTION == 'rollback' }
            }
            steps {
                script {
                    echo "üîÑ Rolling back deployments..."
                    if (DEPLOYMENT_MODE != "elasticsearch-only") {
                        sh "helm rollback kibana -n ${NAMESPACE}"
                    }
                    if (DEPLOYMENT_MODE != "kibana-only") {
                        sh "helm rollback elasticsearch -n ${NAMESPACE}"
                    }
                }
            }
        }
        
        stage('Uninstall') {
            when {
                expression { params.ACTION == 'uninstall' }
            }
            steps {
                script {
                    echo "üóëÔ∏è Uninstalling ELK stack..."
                    if (DEPLOYMENT_MODE != "elasticsearch-only") {
                        sh "helm uninstall kibana -n ${NAMESPACE} || true"
                    }
                    if (DEPLOYMENT_MODE != "kibana-only") {
                        sh "helm uninstall elasticsearch -n ${NAMESPACE} || true"
                    }
                    
                    echo "üßπ Cleaning up namespace..."
                    sh "kubectl delete namespace ${NAMESPACE} --ignore-not-found=true"
                    echo "‚úÖ Cleanup complete!"
                }
            }
        }
    }
    
    post {
        always {
            script {
                if (!params.DRY_RUN && params.ACTION != 'uninstall') {
                    sh """
                        echo "üìä Final Status Check:"
                        kubectl get all -n ${NAMESPACE} || true
                        echo ""
                        echo "üîê Access Information:"
                        echo "Username: elastic"
                        echo "Password: \${ES_PASSWORD}"
                        echo "Namespace: ${NAMESPACE}"
                        kubectl get ingress -n ${NAMESPACE} || true
                    """
                }
            }
        }
        success {
            echo "‚úÖ ELK Stack deployment completed successfully!"
            script {
                if (!params.DRY_RUN && (params.ACTION == 'deploy' || params.ACTION == 'upgrade')) {
                    echo """
üéâ Production Deployment Successful!

üìä Resources Created:
- ‚úÖ Elasticsearch cluster (3 pods)
- ‚úÖ Kibana deployment (${KIBANA_REPLICAS} pods)  
- ‚úÖ Storage volumes (${ES_STORAGE_SIZE} per ES pod)
- ‚úÖ Load balancer (ALB)
- ‚úÖ Security configured

üåê Access Information:
- Kibana URL: http://${KIBANA_DOMAIN}
- Username: elastic  
- Password: Check Jenkins credentials
- Namespace: ${NAMESPACE}

üë• Capacity: Ready for 50 concurrent users!

üí∞ Cost: ~\$1.75/day additional to your existing infrastructure

üîß Next Steps:
1. Configure user authentication
2. Set up index patterns  
3. Create dashboards
4. Configure data retention policies
5. Set up monitoring alerts

üéØ Ticket #269: COMPLETED! ‚úÖ
                    """
                }
            }
        }
        failure {
            echo "‚ùå ELK Stack deployment failed!"
            sh """
                echo "üîç Debugging information:"
                kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' || true
                kubectl get pods -n ${NAMESPACE} -o wide || true
                echo ""
                echo "üîß Troubleshooting tips:"
                echo "1. Check if resources are available on nodes"
                echo "2. Verify storage class 'gp2' is available"
                echo "3. Check security group settings"
                echo "4. Review Helm release status: helm status elasticsearch -n ${NAMESPACE}"
            """ 
        }
    }
}
